// Strings are a far more complicated data structure than most people give them credit for.

fn strings() {
    // Many of same operations available to Vec<T> are available with String.
    // String is actually implemented as a wrapper around a vector of bytes with some extra guarantees, restrictions and capabilities.
    let mut s = String::new();
    // This line creates a new empty string s into which we can load data.

    // Another way to create a string is to use the to_string() method.
    let s = "initial contents".to_string();
    // There's also String::from()
    let s = String::from("initial contents");

    // A String can grow in size and its contents can change, just like the contents of a Vec<T>, if you push more data into it.
    // In addition, you can conveniently use the + operator or the format! macro to concatenate String values.

    // We can grow a String by using the push_str method to append a string slice,
    let mut s = String::from("foo");
    s.push_str("bar");
    // After these two lines, s will contain foobar.
    // The push_str method takes a string slice because we don’t necessarily want to take ownership of the parameter.

    // The push method takes a single character as a parameter and adds it to the String
    let mut s = String::from("lo");
    s.push('l');

    // Often, you’ll want to combine two existing strings. One way to do so is to use the + operator
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used

    // Alternatively,
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");
    let s = format!("{s1}-{s2}-{s3}");
    // The format! macro works like println!, but instead of printing the output to the screen, it returns a String with the contents.
    // The version of the code using format! is much easier to read, and the code generated by the format! macro uses references
    // so that this call doesn’t take ownership of any of its parameters.

    // In many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation.
    // However, if you try to access parts of a String using indexing syntax in Rust, you’ll get an error.
    // A String is a wrapper over a Vec<u8>
}

fn main() {
    strings();
}
